// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Article defines model for Article.
type Article struct {
	// Body 記事本文（HTML形式）
	Body     string   `json:"Body"`
	Category Category `json:"Category"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"CreatedAt"`

	// Description 記事の概要
	Description string `json:"Description"`

	// ID 記事ID
	ID string `json:"ID"`

	// PublishedAt 公開日時
	PublishedAt time.Time `json:"PublishedAt"`

	// Title 記事タイトル
	Title string `json:"Title"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"UpdatedAt"`
}

// ArticleResponse defines model for ArticleResponse.
type ArticleResponse struct {
	Article Article `json:"article"`
}

// ArticlesResponse defines model for ArticlesResponse.
type ArticlesResponse struct {
	// Articles 記事リスト
	Articles   []Article   `json:"articles"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// CategoriesResponse defines model for CategoriesResponse.
type CategoriesResponse struct {
	// Categories カテゴリリスト
	Categories []Category `json:"categories"`
}

// Category defines model for Category.
type Category struct {
	// Name カテゴリ名
	Name string `json:"Name"`

	// Slug カテゴリスラッグ（ID）
	Slug string `json:"Slug"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Detail エラー詳細
	Detail *string `json:"detail,omitempty"`

	// Error エラーメッセージ
	Error string `json:"error"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Status ヘルスチェック結果
	Status string `json:"status"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	// Limit 1ページあたりの記事数
	Limit *int `json:"limit,omitempty"`

	// Page 現在のページ番号
	Page *int `json:"page,omitempty"`

	// Total 総記事数
	Total *int `json:"total,omitempty"`

	// TotalPages 総ページ数
	TotalPages *int `json:"totalPages,omitempty"`
}

// GetArticlesParams defines parameters for GetArticles.
type GetArticlesParams struct {
	// Page ページ番号（デフォルト 1）
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit 取得件数（デフォルト 10）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetLatestArticlesParams defines parameters for GetLatestArticles.
type GetLatestArticlesParams struct {
	// Limit 取得件数（デフォルト 5）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPopularArticlesParams defines parameters for GetPopularArticles.
type GetPopularArticlesParams struct {
	// Limit 取得件数（デフォルト 5）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetArticlesByCategoryParams defines parameters for GetArticlesByCategory.
type GetArticlesByCategoryParams struct {
	// Page ページ番号（デフォルト 1）
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit 取得件数（デフォルト 10）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetZennArticlesParams defines parameters for GetZennArticles.
type GetZennArticlesParams struct {
	// Page ページ番号（デフォルト 1）
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit 取得件数（デフォルト 10）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 記事一覧取得
	// (GET /api/v1/articles)
	GetArticles(ctx echo.Context, params GetArticlesParams) error
	// 最新記事一覧取得
	// (GET /api/v1/articles/latest)
	GetLatestArticles(ctx echo.Context, params GetLatestArticlesParams) error
	// 人気記事一覧取得
	// (GET /api/v1/articles/popular)
	GetPopularArticles(ctx echo.Context, params GetPopularArticlesParams) error
	// 記事詳細取得
	// (GET /api/v1/articles/{id})
	GetArticleById(ctx echo.Context, id string) error
	// カテゴリ一覧取得
	// (GET /api/v1/categories)
	GetCategories(ctx echo.Context) error
	// カテゴリ別記事一覧取得
	// (GET /api/v1/categories/{slug}/articles)
	GetArticlesByCategory(ctx echo.Context, slug string, params GetArticlesByCategoryParams) error
	// Zenn記事一覧取得
	// (GET /api/v1/zenn/articles)
	GetZennArticles(ctx echo.Context, params GetZennArticlesParams) error
	// ヘルスチェック
	// (GET /health)
	HealthCheck(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticles(ctx, params)
	return err
}

// GetLatestArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLatestArticlesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestArticles(ctx, params)
	return err
}

// GetPopularArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetPopularArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPopularArticlesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPopularArticles(ctx, params)
	return err
}

// GetArticleById converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticleById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticleById(ctx, id)
	return err
}

// GetCategories converts echo context to params.
func (w *ServerInterfaceWrapper) GetCategories(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCategories(ctx)
	return err
}

// GetArticlesByCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticlesByCategory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithOptions("simple", "slug", ctx.Param("slug"), &slug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArticlesByCategoryParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticlesByCategory(ctx, slug, params)
	return err
}

// GetZennArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetZennArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetZennArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetZennArticles(ctx, params)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/articles", wrapper.GetArticles)
	router.GET(baseURL+"/api/v1/articles/latest", wrapper.GetLatestArticles)
	router.GET(baseURL+"/api/v1/articles/popular", wrapper.GetPopularArticles)
	router.GET(baseURL+"/api/v1/articles/:id", wrapper.GetArticleById)
	router.GET(baseURL+"/api/v1/categories", wrapper.GetCategories)
	router.GET(baseURL+"/api/v1/categories/:slug/articles", wrapper.GetArticlesByCategory)
	router.GET(baseURL+"/api/v1/zenn/articles", wrapper.GetZennArticles)
	router.GET(baseURL+"/health", wrapper.HealthCheck)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xabW8bxxH+K8S2gD+UMk+yBQT8RllVQyQ2iNoFirj6sDmuyLXvLXd7rlWBgHkHx7Rl",
	"VYJTyXEi1K0T27L8IgF2IlVhnB+zuqP8SX+h2L3j8Y7cIylVfmkgwIAI83bnmWfmmZnd4xyQddXQNaQR",
	"C+TngCVXkQr5x4JJsKwg9tEwdQOZBCP+xYRenmV/y8iSTWwQrGsgD/bWvt7dmfdXn/krN/abjY8vnP3U",
	"+/mB11zcb94EWYCuQtVgu4G/2JJ0Sjb4HxSsovUXwUJav03rX/F/T73rD6lzi9Zf0/o9es0JluXCdSAL",
	"yKzBtrOIibUKqGXBGUhQRTc5tt+aaAbkwW9yHfdyoW+56Dm2xkSQoHKB9Dq0+/Oq31jy7z707zkJB8ak",
	"sVMj0uiINHpBkvL832cgC2Z0U4UE5EEZEjRCsCoEORm3IeaQsfHI2XtUT1jlpLxoP7FBnR+o+5K6d6n7",
	"NFpA648DskSWi5NpBouTCUswCPzI6Ngp0T4l+3MFW1Uxad71Z29W5o+atAuYBIkopMv5hTrfU7dB3adJ",
	"xmIURcx2Pd1j6k9GOS0h/G9f+SubR+tbLQtM9IWNTVQG+YuARyLwNpbPyazJBgJMBiKeyXEnpiOL+ueX",
	"kEyYi6Gw/4gsQ9csgcBhR/n9dNQuEN1OtJf3sW0NNG6lhttdp85/qNsAWYAJUq2hYUZwoGlCrn4DVrAG",
	"21rst0mp82SKu5bQ3zCGuJ/HcvRMr8/UeUrdL6nzirl9UM/jhS7pepcLMQR9nJjthX4Oqqg/aG9pISlK",
	"9sUGdf9O3efU2aZuU6TC84pdGUAGY+IJdV3qbO43G8XJ7jZDkFzVdEWvzA5UHbeWDZwR+f9709TN9PiV",
	"EYFYEcFd4xCbe09etl5tJtCd0TUNyezBDCsMuk0yRM+oWDb1M2fPZwqloogWxID0MUTdf3NGfmKfne2E",
	"xSmIFVRmViqIZKKkHcRNYFLEyscIKqSaTotFILFFKe1+zXoWi1+dOo854I3WD0v+P1cTgPXLA8GFJkTo",
	"SglpJ5EpWMWC+j5K3W8C4mjdofX7fPoIO66/nIjfqBSZxBpBFWSG5USghtbia291jbWe9vat5XVvcSux",
	"n2g7ohMoSKvW1qIY07iUuksJVkTVpbW1GIHq2a13s1oPz7UssJBsm5jMnmdFJzBSMPAnaLZgk2qvyUKp",
	"uLe+sLfWbP2Dc+I8D0oAZl9WESwjE2SBxusK+PNIoVQc+QTFJAz53qDGTGNtRucFVNcIlHlEw4XnkIk1",
	"xGSUOW8bhm7ynEgiOYeukpOXrMzvOrKj7govS5vU2eIJ+iV1/xUAnZia2m82JqB8GWnlzIxuZqZMXSNI",
	"K+83bwZyVbCMQiWEMM4WL/AQBONLG9XE1FQo8CvItMLcOymdlNizuoE0aGCQB6f4f7GsIlVOaw4aOHdl",
	"NBfvkBVERApr57G7wD9sUfcxdV96G6+9X1ajnN7dvrb36DF17niLK97ru4AbN7lmimWQB39ApNApEwY0",
	"oYoIMi2Qv5hqMUjt/WaDujeou0ydJ0zrbiMzGtRnHuYvbMSnmpAlLptsePQIvJmBtkK4LOISUbGGVVsV",
	"yqWW7RlFuVe7P/3oL2+KAEnpiIICIYYkdZUBFV4NQUnSAIjTrHoF5ZIHb0yS2umLNB5HaBgKlnkIcpes",
	"oHZ1QAwx5XTGDK4Q0QAVhD1gx28sebfus7w7LY0OgSXyfK7di4CKLQtrFa61y4jPGsMhTnZVEVxeJ6Lm",
	"xnYeH4qxGMp2bx6u4bZ9SumVR+caP5o0qbvEVRM5yAzYqgrZqCWIFquCsGIlh062qLsy5BRIkEVSC4S/",
	"es1f2YzOREMUgk/5hsOWgwHSGz+U8sZjwhuP6W7sQ5ddnO3/RXzvW1bvMPfTKBteAYZu2Ao0UyWwu7Pj",
	"b949iARKwY7HGjiMBuJ0H2tgKA2kUTa8BuZwuZbeA27f8F58Q+vL1LlN6/eLk9FcGBxXh5kLJ2aL5UE6",
	"iF0x8mRn42wn1zFb3znSEdNG8cQf8lLyXaT34MEq4K03r6XDDVah3UxxMoOtTMTREQ4h7jp1Nlj68Vul",
	"hBoOPQ5i7QpUcPndjIOnpdOHHAfb5P4Vkypj+EQsv05kyjqyMppOMugqtkhsMGwvY9/N6LZ2lOFo96Lb",
	"e4/maf17Wp9vv/74ljpfve/p970Mv3FFDSx7yWtUYc3zrq8l7hCH6vudK1zwFquM4KJYSF0H/fE57oCZ",
	"HEuQd5vMaVGLpXT8Bl6c1Lk5S7ErtcG3P12NvSvhD3z1MzEbew/V/xIo5Xpe3Pmt4NJ9mN7f/yr/+C7q",
	"//EuKvGOqPGw/8ngkBNUO3EzLNc+2CHqQxyPIub4fMTpO9FRYZ8BKVr4NiakZCn7MOek99lbhDoSN5ls",
	"yhD1N6Rpg1vMZ0jTOO83D36TyNYev1b4NZVyFtHjm50DaFZMWEyoTIWhLqv8LXuqEgulYsJi/UVrrem5",
	"C61bP/ov69S503qws7e+0CPE4OX9mSqSL7/NU03XbwQG8OU//87b3g4cSLxbBvmL04miJ/oJQYy/kLTp",
	"WtcmyVfTF6eZdCxkXhFXnzcr8617O607m94DF2SBbbIOUSXEyOdyii5DpapbJP+R9JEEesuEv/qstbwu",
	"WGzlc6zYngzVflLWVcBwhNiH+rXEm5UHb6591yksob+9KIIs63481qr6zfDdyxLnp7nUItC9jCdzbbr2",
	"3wAAAP//E2mKhGsqAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
