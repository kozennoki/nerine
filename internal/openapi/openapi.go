// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Article defines model for Article.
type Article struct {
	// Body 記事本文（HTML形式）
	Body     string   `json:"Body"`
	Category Category `json:"Category"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"CreatedAt"`

	// Description 記事の概要
	Description string `json:"Description"`

	// ID 記事ID
	ID string `json:"ID"`

	// Image 記事画像URL
	Image string `json:"Image"`

	// Title 記事タイトル
	Title string `json:"Title"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"UpdatedAt"`
}

// ArticleResponse defines model for ArticleResponse.
type ArticleResponse struct {
	Article Article `json:"article"`
}

// ArticlesResponse defines model for ArticlesResponse.
type ArticlesResponse struct {
	// Articles 記事リスト
	Articles   []Article   `json:"articles"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// CategoriesResponse defines model for CategoriesResponse.
type CategoriesResponse struct {
	// Categories カテゴリリスト
	Categories []Category `json:"categories"`
}

// Category defines model for Category.
type Category struct {
	// Name カテゴリ名
	Name string `json:"Name"`

	// Slug カテゴリスラッグ（ID）
	Slug string `json:"Slug"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Detail エラー詳細
	Detail *string `json:"detail,omitempty"`

	// Error エラーメッセージ
	Error string `json:"error"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Status ヘルスチェック結果
	Status string `json:"status"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	// Limit 1ページあたりの記事数
	Limit *int `json:"limit,omitempty"`

	// Page 現在のページ番号
	Page *int `json:"page,omitempty"`

	// Total 総記事数
	Total *int `json:"total,omitempty"`

	// TotalPages 総ページ数
	TotalPages *int `json:"totalPages,omitempty"`
}

// GetArticlesParams defines parameters for GetArticles.
type GetArticlesParams struct {
	// Page ページ番号（デフォルト 1）
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit 取得件数（デフォルト 10）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetLatestArticlesParams defines parameters for GetLatestArticles.
type GetLatestArticlesParams struct {
	// Limit 取得件数（デフォルト 5）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPopularArticlesParams defines parameters for GetPopularArticles.
type GetPopularArticlesParams struct {
	// Limit 取得件数（デフォルト 5）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetArticlesByCategoryParams defines parameters for GetArticlesByCategory.
type GetArticlesByCategoryParams struct {
	// Page ページ番号（デフォルト 1）
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit 取得件数（デフォルト 10）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 記事一覧取得
	// (GET /api/v1/articles)
	GetArticles(ctx echo.Context, params GetArticlesParams) error
	// 最新記事一覧取得
	// (GET /api/v1/articles/latest)
	GetLatestArticles(ctx echo.Context, params GetLatestArticlesParams) error
	// 人気記事一覧取得
	// (GET /api/v1/articles/popular)
	GetPopularArticles(ctx echo.Context, params GetPopularArticlesParams) error
	// 記事詳細取得
	// (GET /api/v1/articles/{id})
	GetArticleById(ctx echo.Context, id string) error
	// カテゴリ一覧取得
	// (GET /api/v1/categories)
	GetCategories(ctx echo.Context) error
	// カテゴリ別記事一覧取得
	// (GET /api/v1/categories/{slug}/articles)
	GetArticlesByCategory(ctx echo.Context, slug string, params GetArticlesByCategoryParams) error
	// ヘルスチェック
	// (GET /health)
	HealthCheck(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticles(ctx, params)
	return err
}

// GetLatestArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLatestArticlesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestArticles(ctx, params)
	return err
}

// GetPopularArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetPopularArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPopularArticlesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPopularArticles(ctx, params)
	return err
}

// GetArticleById converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticleById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticleById(ctx, id)
	return err
}

// GetCategories converts echo context to params.
func (w *ServerInterfaceWrapper) GetCategories(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCategories(ctx)
	return err
}

// GetArticlesByCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticlesByCategory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithOptions("simple", "slug", ctx.Param("slug"), &slug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArticlesByCategoryParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticlesByCategory(ctx, slug, params)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/articles", wrapper.GetArticles)
	router.GET(baseURL+"/api/v1/articles/latest", wrapper.GetLatestArticles)
	router.GET(baseURL+"/api/v1/articles/popular", wrapper.GetPopularArticles)
	router.GET(baseURL+"/api/v1/articles/:id", wrapper.GetArticleById)
	router.GET(baseURL+"/api/v1/categories", wrapper.GetCategories)
	router.GET(baseURL+"/api/v1/categories/:slug/articles", wrapper.GetArticlesByCategory)
	router.GET(baseURL+"/health", wrapper.HealthCheck)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
