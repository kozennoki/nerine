// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Article defines model for Article.
type Article struct {
	// Body 記事本文（HTML形式）
	Body     string   `json:"Body"`
	Category Category `json:"Category"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"CreatedAt"`

	// Description 記事の概要
	Description string `json:"Description"`

	// ID 記事ID
	ID string `json:"ID"`

	// Image 記事画像URL
	Image string `json:"Image"`

	// Title 記事タイトル
	Title string `json:"Title"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"UpdatedAt"`
}

// ArticleResponse defines model for ArticleResponse.
type ArticleResponse struct {
	Article Article `json:"article"`
}

// ArticlesResponse defines model for ArticlesResponse.
type ArticlesResponse struct {
	// Articles 記事リスト
	Articles   []Article   `json:"articles"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// CategoriesResponse defines model for CategoriesResponse.
type CategoriesResponse struct {
	// Categories カテゴリリスト
	Categories []Category `json:"categories"`
}

// Category defines model for Category.
type Category struct {
	// Name カテゴリ名
	Name string `json:"Name"`

	// Slug カテゴリスラッグ（ID）
	Slug string `json:"Slug"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Detail エラー詳細
	Detail *string `json:"detail,omitempty"`

	// Error エラーメッセージ
	Error string `json:"error"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Status ヘルスチェック結果
	Status string `json:"status"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	// Limit 1ページあたりの記事数
	Limit *int `json:"limit,omitempty"`

	// Page 現在のページ番号
	Page *int `json:"page,omitempty"`

	// Total 総記事数
	Total *int `json:"total,omitempty"`

	// TotalPages 総ページ数
	TotalPages *int `json:"totalPages,omitempty"`
}

// GetArticlesParams defines parameters for GetArticles.
type GetArticlesParams struct {
	// Page ページ番号（デフォルト 1）
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit 取得件数（デフォルト 10）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetLatestArticlesParams defines parameters for GetLatestArticles.
type GetLatestArticlesParams struct {
	// Limit 取得件数（デフォルト 5）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPopularArticlesParams defines parameters for GetPopularArticles.
type GetPopularArticlesParams struct {
	// Limit 取得件数（デフォルト 5）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetArticlesByCategoryParams defines parameters for GetArticlesByCategory.
type GetArticlesByCategoryParams struct {
	// Page ページ番号（デフォルト 1）
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit 取得件数（デフォルト 10）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetZennArticlesParams defines parameters for GetZennArticles.
type GetZennArticlesParams struct {
	// Page ページ番号（デフォルト 1）
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit 取得件数（デフォルト 10）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 記事一覧取得
	// (GET /api/v1/articles)
	GetArticles(ctx echo.Context, params GetArticlesParams) error
	// 最新記事一覧取得
	// (GET /api/v1/articles/latest)
	GetLatestArticles(ctx echo.Context, params GetLatestArticlesParams) error
	// 人気記事一覧取得
	// (GET /api/v1/articles/popular)
	GetPopularArticles(ctx echo.Context, params GetPopularArticlesParams) error
	// 記事詳細取得
	// (GET /api/v1/articles/{id})
	GetArticleById(ctx echo.Context, id string) error
	// カテゴリ一覧取得
	// (GET /api/v1/categories)
	GetCategories(ctx echo.Context) error
	// カテゴリ別記事一覧取得
	// (GET /api/v1/categories/{slug}/articles)
	GetArticlesByCategory(ctx echo.Context, slug string, params GetArticlesByCategoryParams) error
	// Zenn記事一覧取得
	// (GET /api/v1/zenn/articles)
	GetZennArticles(ctx echo.Context, params GetZennArticlesParams) error
	// ヘルスチェック
	// (GET /health)
	HealthCheck(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticles(ctx, params)
	return err
}

// GetLatestArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLatestArticlesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestArticles(ctx, params)
	return err
}

// GetPopularArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetPopularArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPopularArticlesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPopularArticles(ctx, params)
	return err
}

// GetArticleById converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticleById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticleById(ctx, id)
	return err
}

// GetCategories converts echo context to params.
func (w *ServerInterfaceWrapper) GetCategories(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCategories(ctx)
	return err
}

// GetArticlesByCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticlesByCategory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithOptions("simple", "slug", ctx.Param("slug"), &slug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArticlesByCategoryParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticlesByCategory(ctx, slug, params)
	return err
}

// GetZennArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetZennArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetZennArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetZennArticles(ctx, params)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/articles", wrapper.GetArticles)
	router.GET(baseURL+"/api/v1/articles/latest", wrapper.GetLatestArticles)
	router.GET(baseURL+"/api/v1/articles/popular", wrapper.GetPopularArticles)
	router.GET(baseURL+"/api/v1/articles/:id", wrapper.GetArticleById)
	router.GET(baseURL+"/api/v1/categories", wrapper.GetCategories)
	router.GET(baseURL+"/api/v1/categories/:slug/articles", wrapper.GetArticlesByCategory)
	router.GET(baseURL+"/api/v1/zenn/articles", wrapper.GetZennArticles)
	router.GET(baseURL+"/health", wrapper.HealthCheck)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
