// Package openapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package openapi

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
	"github.com/oapi-codegen/runtime"
)

const (
	ApiKeyAuthScopes = "ApiKeyAuth.Scopes"
)

// Article defines model for Article.
type Article struct {
	// Body 記事本文（HTML形式）
	Body     string   `json:"Body"`
	Category Category `json:"Category"`

	// CreatedAt 作成日時
	CreatedAt time.Time `json:"CreatedAt"`

	// Description 記事の概要
	Description string `json:"Description"`

	// ID 記事ID
	ID string `json:"ID"`

	// Image 記事画像URL
	Image string `json:"Image"`

	// PublishedAt 公開日時
	PublishedAt time.Time `json:"PublishedAt"`

	// Title 記事タイトル
	Title string `json:"Title"`

	// UpdatedAt 更新日時
	UpdatedAt time.Time `json:"UpdatedAt"`
}

// ArticleResponse defines model for ArticleResponse.
type ArticleResponse struct {
	Article Article `json:"article"`
}

// ArticlesResponse defines model for ArticlesResponse.
type ArticlesResponse struct {
	// Articles 記事リスト
	Articles   []Article   `json:"articles"`
	Pagination *Pagination `json:"pagination,omitempty"`
}

// CategoriesResponse defines model for CategoriesResponse.
type CategoriesResponse struct {
	// Categories カテゴリリスト
	Categories []Category `json:"categories"`
}

// Category defines model for Category.
type Category struct {
	// Name カテゴリ名
	Name string `json:"Name"`

	// Slug カテゴリスラッグ（ID）
	Slug string `json:"Slug"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	// Detail エラー詳細
	Detail *string `json:"detail,omitempty"`

	// Error エラーメッセージ
	Error string `json:"error"`
}

// HealthResponse defines model for HealthResponse.
type HealthResponse struct {
	// Status ヘルスチェック結果
	Status string `json:"status"`
}

// Pagination defines model for Pagination.
type Pagination struct {
	// Limit 1ページあたりの記事数
	Limit *int `json:"limit,omitempty"`

	// Page 現在のページ番号
	Page *int `json:"page,omitempty"`

	// Total 総記事数
	Total *int `json:"total,omitempty"`

	// TotalPages 総ページ数
	TotalPages *int `json:"totalPages,omitempty"`
}

// GetArticlesParams defines parameters for GetArticles.
type GetArticlesParams struct {
	// Page ページ番号（デフォルト 1）
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit 取得件数（デフォルト 10）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetLatestArticlesParams defines parameters for GetLatestArticles.
type GetLatestArticlesParams struct {
	// Limit 取得件数（デフォルト 5）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPopularArticlesParams defines parameters for GetPopularArticles.
type GetPopularArticlesParams struct {
	// Limit 取得件数（デフォルト 5）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetArticlesByCategoryParams defines parameters for GetArticlesByCategory.
type GetArticlesByCategoryParams struct {
	// Page ページ番号（デフォルト 1）
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit 取得件数（デフォルト 10）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetZennArticlesParams defines parameters for GetZennArticles.
type GetZennArticlesParams struct {
	// Page ページ番号（デフォルト 1）
	Page *int `form:"page,omitempty" json:"page,omitempty"`

	// Limit 取得件数（デフォルト 10）
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// 記事一覧取得
	// (GET /api/v1/articles)
	GetArticles(ctx echo.Context, params GetArticlesParams) error
	// 最新記事一覧取得
	// (GET /api/v1/articles/latest)
	GetLatestArticles(ctx echo.Context, params GetLatestArticlesParams) error
	// 人気記事一覧取得
	// (GET /api/v1/articles/popular)
	GetPopularArticles(ctx echo.Context, params GetPopularArticlesParams) error
	// 記事詳細取得
	// (GET /api/v1/articles/{id})
	GetArticleById(ctx echo.Context, id string) error
	// カテゴリ一覧取得
	// (GET /api/v1/categories)
	GetCategories(ctx echo.Context) error
	// カテゴリ別記事一覧取得
	// (GET /api/v1/categories/{slug}/articles)
	GetArticlesByCategory(ctx echo.Context, slug string, params GetArticlesByCategoryParams) error
	// Zenn記事一覧取得
	// (GET /api/v1/zenn/articles)
	GetZennArticles(ctx echo.Context, params GetZennArticlesParams) error
	// ヘルスチェック
	// (GET /health)
	HealthCheck(ctx echo.Context) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// GetArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticles(ctx, params)
	return err
}

// GetLatestArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetLatestArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLatestArticlesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetLatestArticles(ctx, params)
	return err
}

// GetPopularArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetPopularArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPopularArticlesParams
	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetPopularArticles(ctx, params)
	return err
}

// GetArticleById converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticleById(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithOptions("simple", "id", ctx.Param("id"), &id, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticleById(ctx, id)
	return err
}

// GetCategories converts echo context to params.
func (w *ServerInterfaceWrapper) GetCategories(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetCategories(ctx)
	return err
}

// GetArticlesByCategory converts echo context to params.
func (w *ServerInterfaceWrapper) GetArticlesByCategory(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "slug" -------------
	var slug string

	err = runtime.BindStyledParameterWithOptions("simple", "slug", ctx.Param("slug"), &slug, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter slug: %s", err))
	}

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetArticlesByCategoryParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetArticlesByCategory(ctx, slug, params)
	return err
}

// GetZennArticles converts echo context to params.
func (w *ServerInterfaceWrapper) GetZennArticles(ctx echo.Context) error {
	var err error

	ctx.Set(ApiKeyAuthScopes, []string{})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetZennArticlesParams
	// ------------- Optional query parameter "page" -------------

	err = runtime.BindQueryParameter("form", true, false, "page", ctx.QueryParams(), &params.Page)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter page: %s", err))
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", ctx.QueryParams(), &params.Limit)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter limit: %s", err))
	}

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.GetZennArticles(ctx, params)
	return err
}

// HealthCheck converts echo context to params.
func (w *ServerInterfaceWrapper) HealthCheck(ctx echo.Context) error {
	var err error

	// Invoke the callback with all the unmarshaled arguments
	err = w.Handler.HealthCheck(ctx)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
	RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/api/v1/articles", wrapper.GetArticles)
	router.GET(baseURL+"/api/v1/articles/latest", wrapper.GetLatestArticles)
	router.GET(baseURL+"/api/v1/articles/popular", wrapper.GetPopularArticles)
	router.GET(baseURL+"/api/v1/articles/:id", wrapper.GetArticleById)
	router.GET(baseURL+"/api/v1/categories", wrapper.GetCategories)
	router.GET(baseURL+"/api/v1/categories/:slug/articles", wrapper.GetArticlesByCategory)
	router.GET(baseURL+"/api/v1/zenn/articles", wrapper.GetZennArticles)
	router.GET(baseURL+"/health", wrapper.HealthCheck)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"0gr8KgAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
